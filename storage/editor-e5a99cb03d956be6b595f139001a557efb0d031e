{"mode":"editor","version":1,"windowDimensions":{"x":4,"y":23,"width":1362,"height":745,"maximized":true},"grammars":{"deserializer":"GrammarRegistry","grammarOverridesByPath":{}},"project":{"paths":["/Users/ustrajunior/code/nextbit/superwifi"],"buffers":[{"text":"class User < ActiveRecord::Base\n  has_paper_trail :on => [:update, :destroy], :skip => [:actions, :user_identify, :last_sign_in_at, :current_sign_in_at, :sign_in_count, :confirmation_token, :updated_at, :confirmation_sent_at, :unconfirmed_email, :failed_attempts, :current_sign_in_ip, :last_sign_in_ip, :client_id, :provider, :uid, :password_changed, :password_unchanged, :sms_token, :sms_token_sent_at, :unlock_token, :password_reset_count, :sms_confirmed_at, :remember_created_at, :reset_password_token, :reset_password_sent_at, :remember_token, :slug]\n  # Include default devise modules. Others available are:\n  # :token_authenticatable,\n  # :timeoutable and :omniauthable, :confirmable, :recoverable,\n  devise :database_authenticatable, :registerable, :confirmable,\n         :rememberable, :trackable, :validatable,\n         :lockable, :async, :omniauthable, :omniauth_providers => [:facebook]\n\n  paginates_per 15\n\n  extend FriendlyId\n  friendly_id :login, :use => [:slugged, :finders]\n\n  default_scope { where(valid_record: true) }\n\n  attr_accessor :login\n  attr_accessor :radius_username\n  attr_accessor :country_code\n  attr_accessor :updating_phone\n\n  VALIDACAO_GROUP = 'validacao'\n  NAVNORMAL_GROUP = 'navnormal'\n\n  include UserValidations\n\n  before_validation :format_cpf, if: :cpf?\n  after_create :export_to_radius\n  after_update :reset_counters\n  before_create :set_accepted_terms_at\n  before_create :generate_sms_code\n  before_create :set_age\n  before_validation :set_client, if: Proc.new {|u| u.client_id.nil? }\n  before_validation :clean_phone\n\n  has_and_belongs_to_many :permissions\n  belongs_to :permission_group\n  has_and_belongs_to_many :clients\n  has_many :user_logs\n  belongs_to :client\n  has_many :tickets\n\n  accepts_nested_attributes_for :permissions\n\n  scope :admins, -> { where(role: 'admin') }\n  scope :supers, -> { where(role: 'super') }\n  scope :nextbits, -> { where(role: 'nextbit') }\n  scope :users, -> { where(role: 'user') }\n  scope :confirmed_today, -> { where(\"confirmed_at >= ?\", Time.zone.now.beginning_of_day) }\n  scope :created_today, -> { where('users.created_at >= ? and users.created_at <= ?', Time.zone.now.beginning_of_day, Time.zone.now.end_of_day) }\n  scope :not_confirmed, -> { where(confirmed_at: nil) }\n\n  def full_confirmed?\n    sms_confirmed? && email_confirmed?\n  end\n\n  def any_confirmation?\n    sms_confirmed? || email_confirmed? || forced_confirmation\n  end\n\n  def email_confirmed?\n    !confirmed_at.nil?\n  end\n\n  def completed_registration?\n    !(!Phone.valid?(phone, phone_country) || gender.nil? || birth_date.nil? || email.nil?)\n  end\n\n  def has_to_complete_registration?\n    sign_in_count > 1 && !completed_registration?\n  end\n\n  def format_cpf\n    self.cpf = Cpf.only_numbers(self.cpf)\n  end\n\n  def only_cpf_numbers\n    Cpf.only_numbers(self.cpf)\n  end\n\n  def self.check_identity(cpf, passport)\n    user = self.check_cpf(cpf) if Cpf.present?(cpf)\n    if user.nil?\n      user = self.check_passport(passport) if Cpf.present?(passport)\n    end\n    user\n  end\n\n  def self.check_passport(passport)\n    where(passport_number: passport).first\n  end\n\n  def self.check_cpf(cpf)\n    where(cpf: Cpf.formatted(cpf)).first\n  end\n\n  def self.admins_by_client(client_id=nil)\n    Rails.cache.fetch(['users', 'admins_by_client', client_id, self]) do\n      client_id.nil? ? admins : where(client_id: client_id).admins\n    end\n  end\n\n  def self.by_client(client_id=nil)\n    Rails.cache.fetch(['users', 'by_client', client_id, self]) do\n      client_id.nil? ? users : where(client_id: client_id).users\n    end\n  end\n\n  def self.by_group(group_id)\n    Rails.cache.fetch(['users', 'by_group', group_id, self]) do\n      joins(\"INNER JOIN clients on clients.id = users.client_id\").\n        joins(\"INNER JOIN groups on clients.group_id = groups.id\").\n        where(\"groups.id = ?\", group_id).users\n    end\n  end\n\n  def accept_terms!\n    self.accepted_terms = true\n    self.accepted_terms_at = Time.zone.now\n    self.save(validate: false)\n  end\n\n  def must_accept_terms?\n    self.accepted_terms == false\n  end\n\n  def set_accepted_terms_at\n    self.accepted_terms_at = self.created_at\n  end\n\n  def active_for_authentication?\n    true\n  end\n\n  def radius_username\n\t\temail\n  end\n\n  def md5_radius_user_pass\n    MD5Generator.new_radius_pass(\"#{id}\")\n  end\n\n  def after_database_authentication\n    if $redis.get(\"c_#{self.client_id}_radius\").to_bool\n      unless RadCheck.where(username: radius_username).present?\n        RadCheck.save_on_radius(self)\n        RadUserGroup.save_user_group(self, VALIDACAO_GROUP)\n      end\n    end\n  end\n\n  def client_admin?\n    role == 'admin'\n  end\n\n  def admin?\n    role == 'admin' || role == 'nextbit' || role == 'super'\n  end\n\n  def nextbit?\n    role == 'nextbit'\n  end\n\n  def valid_sms_token?(token)\n   true if token != nil &&\n      sms_token != nil &&\n      sms_token.to_i == token.to_i\n  end\n\n  def confirm_sms_token(token)\n    if valid_sms_token?(token)\n      self.sms_token_sent_at = nil\n      self.sms_confirmed = true\n      self.sms_confirmed_at = Time.zone.now\n      self.sms_token = nil\n      self.save(validate: false)\n\n      if RedisChecker.client(self.client_id, \"radius\")\n        RadUserGroup.change_user_group(self.radius_username, NAVNORMAL_GROUP)\n      end\n    end\n  end\n\n  def confirm!\n    super\n    if RedisChecker.client(self.client_id, \"radius\")\n      RadUserGroup.change_user_group(self.radius_username, NAVNORMAL_GROUP)\n    end\n  end\n\n  def generate_sms_code\n    self.sms_token = loop do\n      token = rand.to_s[2..11]\n      break token unless User.select(:sms_token).find_by(sms_token: token)\n    end\n  end\n\n  def full_phone\n    \"#{phone_country_code}#{phone}\"\n  end\n\n  def self.find_by_login(login)\n    where([\"email = :email\", { email: login }]).first\n  end\n\n  def phone_country_code\n    user_phone_country.country_code\n  end\n\n  def user_phone_country\n    user_country = phone_country? ? phone_country : 'brazil'\n    Country.find_country_by_name(user_country)\n  end\n\n  def self.new_with_session(params, session)\n    super.tap do |user|\n      if data = session[\"devise.facebook_data\"] && session[\"devise.facebook_data\"][\"extra\"][\"raw_info\"]\n        user.email = data[\"email\"] if user.email.blank?\n      end\n    end\n  end\n\n  def self.find_for_facebook_oauth(auth)\n    where(auth.slice(:provider, :uid)).first\n  end\n\n  def password_required?\n    super && provider.blank?\n  end\n\n  def update_with_password(params, *options)\n    if encrypted_password.blank?\n      update_attributes(params, *options)\n    else\n      super\n    end\n  end\n\n  def confirm_user\n    self.sms_token_sent_at = nil\n    self.sms_token = nil\n    self.forced_confirmation = true\n    self.save(validate: false)\n    if RedisChecker.client(self.client_id, \"radius\")\n      RadUserGroup.change_user_group(self.radius_username, NAVNORMAL_GROUP)\n    end\n  end\n\n  # check email address with mailgun webservice\n  # api_key=pubkey-5ogiflzbnjrljiky49qxsiozqef5jxp7&address=asas@asasas.com\n  def valid_email?\n    if Rails.env.production?\n      begin\n        mailgun_url = URI( Rails.application.secrets.mailgun_validate_email_url )\n        pub_key = Rails.application.secrets.mailgun_key\n        bounce_url = \"#{Rails.application.secrets.mailgun_bounce_check_url}#{email}\"\n        (check_email_on_mailgun(mailgun_url, pub_key, email) && check_bounce_on_mailgun(bounce_url)) ? true : false\n      rescue EmailVerifier::FailureException, EmailVerifier::NoMailServerException, EmailVerifier::OutOfMailServersException, EmailVerifier::NotConnectedException => e\n        false\n      end\n    else\n      true\n    end\n  end\n\n  def normalize_friendly_id(string)\n    SecureRandom.uuid\n  end\n\n  def max_password_resets?\n    password_reset_count <= 2\n  end\n\n  private\n\n  def clean_phone\n    if phone?\n      self.phone = User.only_numbers(phone) if phone.match(/[^0-9]/)\n    end\n  end\n\n  def self.only_numbers(value)\n    response = (value == '' || value.nil?) ? nil : value.gsub(/[^0-9]/, \"\")\n    response = value if response == ''\n    response\n  end\n\n  def set_client\n    self.client_id = Client.current_id\n  end\n\n  def set_age\n    self.age = Calculations.age(birth_date)\n  end\n\n  def reset_counters\n    if self.encrypted_password_changed?\n      self.update_column(:password_reset_count, 0)\n    end\n  end\n\n  def passport_with_empty_space\n    if passport_number? && passport_number.match(/\\s/)\n      errors.add(:passport_number, I18n.t('activerecord.errors.models.user.invalid_passport_number'))\n    end\n  end\n\n  def export_to_radius\n    if RedisChecker.client(self.client_id, \"radius\")\n      RadCheck.save_on_radius(self)\n      RadUserGroup.save_user_group(self, VALIDACAO_GROUP)\n    end\n  end\n\n  def self.find_first_by_auth_conditions(warden_conditions)\n    conditions = warden_conditions.dup\n    if login = conditions.delete(:login)\n      where(conditions).where([\"email = :email\", { email: login }]).first\n    else\n      where(conditions).first\n    end\n  end\n\n  def check_email_with_smtp(address)\n    EmailVerifier.check(address)\n  end\n\n  def check_email_on_mailgun(uri, pub_key, address)\n    Net::HTTP.start(uri.host, uri.port, :use_ssl => uri.scheme == 'https') do |http|\n      request = Net::HTTP::Get.new(uri.request_uri)\n      request.set_form_data({ api_key: pub_key,\n                            address: address,\n                          })\n      response = ActiveSupport::JSON.decode(http.request(request).body)\n      response[\"is_valid\"]\n    end\n  end\n\n  def check_bounce_on_mailgun(uri_check)\n    RestClient.get(uri_check) do |response|\n      res =  JSON.parse(response).with_indifferent_access\n      return res[:message] =~ /Address not found in bounces table/\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[139,16],[139,16]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":18,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/ustrajunior/code/nextbit/superwifi/app/models/user.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"b6558557a211617b0a82be214d4509257832d88a","deserializer":"TextBuffer"},{"text":"require 'digest/md5'\n\nclass MD5Generator\n\tdef self.new_radius_pass(str)\n\t\tDigest::MD5.hexdigest(\"#{str}\")\n\tend\nend\n","markers":{"markers":{"1":{"id":1,"range":[[4,33],[4,33]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":42,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"},"2":{"id":2,"range":[[4,32],[4,33]],"tailed":true,"reversed":false,"valid":true,"invalidate":"overlap","persistent":true,"properties":{},"deserializer":"Marker"},"3":{"id":3,"range":[[4,23],[4,24]],"tailed":true,"reversed":false,"valid":true,"invalidate":"overlap","persistent":true,"properties":{},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/ustrajunior/code/nextbit/superwifi/app/services/md5_generator.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"3cbad934adb93805603bfc40bf978e0fc99f7913","deserializer":"TextBuffer"},{"text":"# MySQL.  Versions 4.1 and 5.0 are recommended.\n#\n# Install the MySQL driver:\n#   gem install mysql2\n#\n# And be sure to use new-style password hashing:\n#   http://dev.mysql.com/doc/refman/5.0/en/old-client.html\ndevelopment:\n  adapter: mysql2\n  encoding: utf8\n  reconnect: true\n  database: superwifi_development\n  pool: 5\n  username: root\n  password: \"123456\"\n  server: 127.0.0.1\n\n# Warning: The database defined as \"test\" will be erased and\n# re-generated from your development database when you run \"rake\".\n# Do not set this db to the same as development or production.\ntest:\n  adapter: mysql2\n  encoding: utf8\n  reconnect: true\n  database: superwifi_test\n  pool: 5\n  username: root\n  password: \"\"\n  server: 127.0.0.1\n\nproduction:\n  adapter: mysql2\n  encoding: utf8\n  database: <%= ENV['RDS_DB_NAME'] %>\n  username: <%= ENV['RDS_USERNAME'] %>\n  password: <%= ENV['RDS_PASSWORD'] %>\n  host: <%= ENV['RDS_HOSTNAME'] %>\n  port: <%= ENV['RDS_PORT'] %>\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":52,"preserveFolds":true,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/ustrajunior/code/nextbit/superwifi/config/database.yml","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"1b51ba404c0a5dc47b1de490dd6f44959c322eca","deserializer":"TextBuffer"},{"text":"class ClientsController < InheritedResources::Base\n  respond_to :html\n  layout 'admin'\n  authorize_resource\n  decorates_assigned :client, :clients\n  responders :flash\n\n  add_breadcrumb 'breadcrumb.clients', :clients_path, only: :index\n  add_breadcrumb 'breadcrumb.profile', :client_path, only: :show\n\n  def index\n    return redirect_to choose_client_path unless current_user.nextbit?\n    super\n  end\n\n  def create\n    create! do |success, failure|\n      success.html { redirect_to client_path(@client) }\n      failure.html { render :new }\n    end\n  end\n\n  def update\n    update! do |success, failure|\n      success.html { redirect_to client_path(@client) }\n      failure.html { render :edit }\n    end\n  end\n\n  private\n\n  def permitted_params\n    params.permit(client: [:group_id, :name, :subdomain, :contact_email, :controller_brand, :public_ip,\n                                   :contact_fone, :spokesman, :logo_image, :continue_url, :time_zone,\n                                   :client_configurations_attributes => [:key, :value]])\n  end\n\n  protected\n\n  def resource\n    @client = Client.find_by(subdomain: params[:id])\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[16,33],[16,33]],"tailed":false,"reversed":true,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":62,"autoscroll":true,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/ustrajunior/code/nextbit/superwifi/app/controllers/clients_controller.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"8d9201dd3ef3096a1bf269c9c3e8238e55ab2a96","deserializer":"TextBuffer"},{"text":"require \"application_responder\"\nrequire \"breadcrumbs\"\n\nclass ApplicationController < ActionController::Base\n  theme :theme_resolver\n\n  self.responder = ApplicationResponder\n  respond_to :html\n\n  protect_from_forgery with: :exception\n  before_action :has_current_client?\n  before_action :authenticate_user!\n  before_action :set_locale\n  before_action :validate_page\n  around_action :user_time_zone, :if => :current_client\n\n  before_action :configure_permitted_parameters, if: :devise_controller?\n  before_action do\n    resource = controller_name.singularize.to_sym\n    method = \"#{resource}_params\"\n    params[resource] &&= send(method) if respond_to?(method, true)\n  end\n  before_action :set_subdomain_to_mailer\n  # before_action :allow_public_access?\n\n  add_breadcrumb 'breadcrumb.dashboard', '/'\n\n  rescue_from CanCan::AccessDenied do |exception|\n    redirect_to dashboard_url, alert: I18n.t('exception.not_authorized')\n  end\n\n  def theme_resolver\n    if current_client && current_client.theme && File.exists?(\"#{Rails.root}/app/themes/#{current_client.theme}\")\n      current_client.theme\n    else\n      'application'\n    end\n  end\n\n  def user_time_zone(&block)\n    begin\n      Time.use_zone(current_client.try(:time_zone), &block)\n    rescue\n      Time.use_zone(Time.zone, &block)\n    end\n  end\n\n  def has_current_client?\n    # redirect_to choose_client_path, alert: I18n.t('exception.without_client') if current_client.nil?\n  end\n\n  def after_sign_in_path_for(resource)\n    RoutesManager.new.after_sign_in(resource, current_subdomain)\n  end\n\n  def current_user\n    super.decorate unless super.nil?\n  end\n\n  def current_client\n    client = CurrentClient.new(current_subdomain, session[:client_subdomain]).retrieve\n    begin\n      Client.current_id = client.id\n    rescue\n    end\n    client.decorate if client\n  end\n  helper_method :current_client\n\n  def current_subdomain\n    request.host.split('.').first\n  end\n  helper_method :current_subdomain\n\n  private\n\n  def set_locale\n    begin\n    #   if Dashboard.subdomain_names.include?(current_subdomain)\n    #     I18n.locale = :pt\n    #   else\n        session_locale(params[:locale])\n        I18n.locale = session[:user_locale] || I18n.default_locale # || extract_locale_from_accept_language_header\n      # end\n    rescue\n      I18n.locale = I18n.default_locale\n    end\n  end\n\n  def session_locale(locale)\n    session[:user_locale] = locale if locale\n  end\n\n  def extract_locale_from_accept_language_header\n    request.env['HTTP_ACCEPT_LANGUAGE'].scan(/^[a-z]{2}/).first\n  end\n\n  def set_subdomain_to_mailer\n    if current_client\n      host = request.host.sub(request.host.split('.')[0], current_client.subdomain)\n    else\n      host = request.host\n    end\n    ActionMailer::Base.default_url_options = { host: \"#{host}\", port: request.port }\n  end\n\n  def validate_page\n    if user_signed_in? && !current_user.nextbit?\n      if current_user.role == 'user' && Dashboard.subdomain_names.include?(current_subdomain) && !request.url.match(/cst/).present?\n        redirect_to root_url.sub(current_user.client.group.slug, current_user.client.subdomain), alert: I18n.t('exception.not_authorized')\n      elsif current_user.role == 'user' && Dashboard.subdomain_names.include?(current_subdomain) && request.url.match(/cst/).present?\n        #FIXME refactor needed\n      elsif Dashboard.subdomain_names.include?(current_subdomain) && !valid_no_client_url? && !current_client\n        redirect_to choose_client_path\n      end\n    end\n  end\n\n  protected\n\n  def may_access_now?\n    route = RoutesManager.new.by_situation(current_user, cookies, {current_route: request.env['PATH_INFO']} )\n    redirect_to route unless route.nil?\n  end\n\n  def valid_no_client_url?\n    requested_url = request.url.split('/').last\n    ['choose_client','login', 'logout'].include?(requested_url) || requested_url.match(/\\?client=/)\n  end\n\n  # def allow_public_access?\n  #   paths = [\n  #     choose_client_path\n  #   ]\n  #   if current_subdomain != 'dashboard' && paths.include?(request.path.sub(root_path, \"/\"))\n  #     redirect_to root_path, alert: I18n.t('exception.access_dashboard')\n  #   end\n  # end\n\n  def configure_permitted_parameters\n    devise_parameter_sanitizer.for(:sign_up) do |u|\n      u.permit(:name, :email, :email_confirmation, :provider, :uid, :gender, :password,\n               :password_confirmation, :cpf, :passport_number, :permission_ids,\n               :passport_country, :birth_date, :phone, :phone_country, :receive_emails,\n               :accepted_terms, :client_id, :avatar, :receive_sms_ad, :rg)\n    end\n    devise_parameter_sanitizer.for(:sign_in) { |u| u.permit(:login, :email, :password, :remember_me) }\n    devise_parameter_sanitizer.for(:account_update) do |u|\n      u.permit(:name, :email, :phone_country, :phone, :gender, :email_confirmation, :password,\n               :password_confirmation, :current_password, :birth_date, :receive_emails, :rg)\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":66},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/ustrajunior/code/nextbit/superwifi/app/controllers/application_controller.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"59511a243e61ec89db647731320f903014fca980","deserializer":"TextBuffer"},{"text":"# encoding: utf-8\n\nclass DesktopBannerUploader < CarrierWave::Uploader::Base\n  include CarrierWave::MiniMagick\n\n  def store_dir\n    \"uploads/#{model.client.subdomain}/#{model.class.to_s.underscore}/#{mounted_as}/#{model.id}\"\n  end\n\n  version :thumb do\n    process :resize_to_fit => [167,50]\n  end\n\n  def extension_white_list\n    %w(jpg jpeg gif png)\n  end\n\n  def filename\n    \"#{secure_token}.#{file.extension}\" if original_filename.present?\n  end\n\n  # attr_reader :width, :height\n  # before :cache, :capture_size\n  # def capture_size(file)\n  #   debugger\n  #   if version_name.blank?\n  #     if file.path.nil?\n  #       img = MiniMagick::Image.read(file.file)\n  #       @width = img[:width]\n  #       @height = img[:height]\n  #     else\n  #       @width, @height = `identify -format \"%wx %h\" #{file.path}`.split(/x/).map{|dim| dim.to_i }\n  #     end\n  #   end\n  # end\n\n  process :resize_to_fill => [1170,350]\n\n  protected\n\n  def secure_token\n    var = :\"@#{mounted_as}_secure_token\"\n    model.instance_variable_get(var) or model.instance_variable_set(var, SecureRandom.uuid)\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":90},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/ustrajunior/code/nextbit/superwifi/app/uploaders/desktop_banner_uploader.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"a3025206a2084015ed2f6793aa01381b0368201d","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":3,"items":[{"id":18,"softTabs":true,"displayBuffer":{"id":19,"softWrapped":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/ustrajunior/code/nextbit/superwifi/app/models/user.rb","invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"TokenizedBuffer"},"invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":42,"softTabs":false,"displayBuffer":{"id":43,"softWrapped":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/ustrajunior/code/nextbit/superwifi/app/services/md5_generator.rb","invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"TokenizedBuffer"},"invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":52,"softTabs":true,"displayBuffer":{"id":53,"softWrapped":true,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/ustrajunior/code/nextbit/superwifi/config/database.yml","invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"TokenizedBuffer"},"invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":62,"softTabs":true,"displayBuffer":{"id":63,"softWrapped":true,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/ustrajunior/code/nextbit/superwifi/app/controllers/clients_controller.rb","invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"TokenizedBuffer"},"invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":66,"softTabs":true,"displayBuffer":{"id":67,"softWrapped":true,"editorWidthInChars":null,"scrollTop":576,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/ustrajunior/code/nextbit/superwifi/app/controllers/application_controller.rb","invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"TokenizedBuffer"},"invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":90,"softTabs":true,"displayBuffer":{"id":91,"softWrapped":true,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/ustrajunior/code/nextbit/superwifi/app/uploaders/desktop_banner_uploader.rb","invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"TokenizedBuffer"},"invisibles":{"eol":"¬","space":"·","tab":"»","cr":"¤"},"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"}],"activeItemURI":"/Users/ustrajunior/code/nextbit/superwifi/app/uploaders/desktop_banner_uploader.rb","focused":false,"deserializer":"Pane"},"activePaneId":3,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-ruby","language-yaml","language-hyperlink","language-todo"],"deserializer":"Workspace"},"packageStates":{"fuzzy-finder":{"/Users/ustrajunior/code/nextbit/superwifi/app/models/user.rb":1425471422765,"/Users/ustrajunior/code/nextbit/superwifi/app/services/md5_generator.rb":1426103082716,"/Users/ustrajunior/code/nextbit/superwifi/config/database.yml":1426103520647,"/Users/ustrajunior/code/nextbit/superwifi/app/controllers/clients_controller.rb":1426103535295,"/Users/ustrajunior/code/nextbit/superwifi/app/controllers/application_controller.rb":1426104113835,"/Users/ustrajunior/code/nextbit/superwifi/app/uploaders/desktop_banner_uploader.rb":1426104126519},"metrics":{"sessionLength":65998865},"tree-view":{"directoryExpansionStates":{"/Users/ustrajunior/code/nextbit/superwifi":{"isExpanded":true,"entries":{".git":{"isExpanded":false,"entries":{}},".vagrant":{"isExpanded":false,"entries":{}},"app":{"isExpanded":true,"entries":{"assets":{"isExpanded":false,"entries":{}},"controllers":{"isExpanded":false,"entries":{}},"decorators":{"isExpanded":false,"entries":{}},"helpers":{"isExpanded":false,"entries":{}},"mailers":{"isExpanded":false,"entries":{}},"models":{"isExpanded":false,"entries":{}},"services":{"isExpanded":false,"entries":{}},"themes":{"isExpanded":false,"entries":{}},"uploaders":{"isExpanded":false,"entries":{}},"validators":{"isExpanded":false,"entries":{}},"views":{"isExpanded":false,"entries":{}},"workers":{"isExpanded":false,"entries":{}}}},"bin":{"isExpanded":false,"entries":{}},"config":{"isExpanded":false,"entries":{}},"cookbooks":{"isExpanded":false,"entries":{}},"db":{"isExpanded":false,"entries":{}},"lib":{"isExpanded":false,"entries":{}},"log":{"isExpanded":false,"entries":{}},"public":{"isExpanded":false,"entries":{}},"spec":{"isExpanded":false,"entries":{}},"tmp":{"isExpanded":false,"entries":{}},"vendor":{"isExpanded":false,"entries":{}}}}},"selectedPath":"/Users/ustrajunior/code/nextbit/superwifi/app/uploaders","hasFocus":true,"attached":true,"scrollLeft":0,"scrollTop":28,"width":200},"find-and-replace":{"viewState":"","modelState":{"useRegex":false,"inCurrentSelection":false,"caseSensitive":false,"wholeWord":false},"projectViewState":"","resultsModelState":{"useRegex":false,"caseSensitive":false},"findHistory":["radius",".size"],"replaceHistory":[],"pathsHistory":[]},"keybinding-resolver":{}}}